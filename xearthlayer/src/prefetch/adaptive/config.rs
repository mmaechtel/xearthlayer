//! Configuration for the adaptive prefetch system.
//!
//! This module provides configuration types for the adaptive prefetch coordinator,
//! calibration thresholds, and strategy tuning parameters.
//!
//! # Configuration Levels
//!
//! The configuration is organized into three tiers:
//!
//! 1. **User-facing options**: Simple toggles and mode selection (`enabled`, `mode`)
//! 2. **Advanced tuning**: Parameters for users who understand the system
//! 3. **Calibration thresholds**: Performance-based mode selection
//!
//! # Example Configuration (INI)
//!
//! ```ini
//! [prefetch]
//! enabled = true
//! mode = auto
//! strategy = adaptive
//!
//! [prefetch.calibration]
//! aggressive_threshold = 30
//! opportunistic_threshold = 10
//! sample_duration = 60
//! ```

use std::time::Duration;

use crate::config::PrefetchSettings;
use crate::service::PrefetchConfig;

/// Configuration for the adaptive prefetch system.
///
/// This is the top-level configuration that controls all aspects of
/// adaptive prefetching, including mode selection, strategy parameters,
/// and calibration thresholds.
#[derive(Debug, Clone)]
pub struct AdaptivePrefetchConfig {
    /// Whether prefetch is enabled at all.
    pub enabled: bool,

    /// Strategy mode selection.
    ///
    /// - `Auto`: Select mode based on calibration results
    /// - `Aggressive`: Always use position-based triggers
    /// - `Opportunistic`: Always use circuit breaker triggers
    /// - `Disabled`: Never prefetch (manual override)
    pub mode: PrefetchMode,

    /// Automatically disable prefetch if performance is too low.
    ///
    /// When `Auto`, prefetch is disabled if throughput falls below
    /// `calibration.opportunistic_threshold` during calibration.
    pub low_performance_killswitch: KillswitchMode,

    /// Position trigger threshold (degrees into DSF tile).
    ///
    /// When mode is Aggressive, prefetch triggers at this position.
    /// Must be less than X-Plane's 0.6° trigger point.
    /// Range: 0.1 - 0.5
    pub trigger_position: f64,

    /// Lead distance (degrees ahead to prefetch).
    ///
    /// How far ahead of the aircraft to prefetch tiles.
    /// Range: 1 - 4
    pub lead_distance: u8,

    /// Band width (DSF tiles perpendicular to travel).
    ///
    /// Width of prefetch band on each side of flight path.
    /// A value of 2 means ±2 DSF tiles = 5 tiles wide total.
    /// Range: 1 - 4
    pub band_width: u8,

    /// Maximum tiles per prefetch cycle.
    ///
    /// Caps tiles submitted in a single prefetch operation.
    /// Range: 500 - 10000
    pub max_tiles_per_cycle: u32,

    /// Ground strategy ring radius (degrees).
    ///
    /// Radius of prefetch ring when aircraft is on ground.
    /// Range: 0.5 - 2.0
    pub ground_ring_radius: f64,

    /// Time budget safety margin (percentage as decimal).
    ///
    /// Only prefetch if estimated time < available time × margin.
    /// Range: 0.5 - 0.9
    pub time_budget_margin: f64,

    /// Calibration thresholds and parameters.
    pub calibration: CalibrationConfig,

    /// Ground speed threshold for ground vs cruise detection (knots).
    ///
    /// Aircraft with ground speed below this AND AGL below `agl_threshold_ft`
    /// are considered on the ground.
    pub ground_speed_threshold_kt: f32,

    /// AGL threshold for ground vs cruise detection (feet).
    ///
    /// Aircraft with AGL below this AND ground speed below `ground_speed_threshold_kt`
    /// are considered on the ground.
    pub agl_threshold_ft: f32,

    /// Track stability threshold (degrees).
    ///
    /// Track deviation must be less than this for the track to be
    /// considered stable after a turn.
    pub track_stability_threshold: f64,

    /// Turn detection threshold (degrees).
    ///
    /// Track change greater than this triggers turn detection.
    pub turn_threshold: f64,

    /// Duration track must be stable to consider it "stabilized".
    pub track_stability_duration: Duration,
}

impl Default for AdaptivePrefetchConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            mode: PrefetchMode::Auto,
            low_performance_killswitch: KillswitchMode::Auto,
            trigger_position: 0.35,
            lead_distance: 2,
            band_width: 2,
            max_tiles_per_cycle: 3000,
            ground_ring_radius: 1.0,
            time_budget_margin: 0.7,
            calibration: CalibrationConfig::default(),
            ground_speed_threshold_kt: 40.0,
            agl_threshold_ft: 20.0,
            track_stability_threshold: 5.0,
            turn_threshold: 15.0,
            track_stability_duration: Duration::from_secs(10),
        }
    }
}

impl AdaptivePrefetchConfig {
    /// Create adaptive config from the config file's prefetch settings.
    ///
    /// Maps the user-facing `PrefetchSettings` to the internal `AdaptivePrefetchConfig`,
    /// including calibration thresholds and mode selection.
    #[allow(dead_code)] // May be used in the future for direct config file access
    pub fn from_prefetch_settings(settings: &PrefetchSettings) -> Self {
        let mode = settings.mode.parse().unwrap_or(PrefetchMode::Auto);

        Self {
            enabled: settings.enabled,
            mode,
            max_tiles_per_cycle: settings.max_tiles_per_cycle as u32,
            calibration: CalibrationConfig {
                aggressive_threshold: settings.calibration_aggressive_threshold,
                opportunistic_threshold: settings.calibration_opportunistic_threshold,
                sample_duration: Duration::from_secs(settings.calibration_sample_duration),
                ..Default::default()
            },
            ..Default::default()
        }
    }

    /// Create adaptive config from the orchestrator's prefetch config.
    ///
    /// This is the primary constructor used by the service orchestrator.
    pub fn from_prefetch_config(config: &PrefetchConfig) -> Self {
        let mode = config.mode.parse().unwrap_or(PrefetchMode::Auto);

        Self {
            enabled: config.enabled,
            mode,
            max_tiles_per_cycle: config.max_tiles_per_cycle as u32,
            calibration: CalibrationConfig {
                aggressive_threshold: config.calibration_aggressive_threshold,
                opportunistic_threshold: config.calibration_opportunistic_threshold,
                sample_duration: Duration::from_secs(config.calibration_sample_duration),
                ..Default::default()
            },
            ..Default::default()
        }
    }

    /// Get the turn detection threshold in degrees.
    pub fn turn_threshold_deg(&self) -> f64 {
        self.turn_threshold
    }
}

/// Strategy mode for prefetch triggering.
///
/// Controls when and how prefetch jobs are submitted.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum PrefetchMode {
    /// Select trigger mode based on calibration results.
    ///
    /// This is the recommended setting. The system measures throughput
    /// during the initial load and selects the appropriate mode.
    #[default]
    Auto,

    /// Position-based trigger (0.3° into DSF tile).
    ///
    /// Use this for fast connections that can complete prefetch
    /// well before X-Plane needs the tiles.
    Aggressive,

    /// Circuit breaker trigger (when X-Plane finishes loading).
    ///
    /// Use this for moderate connections. Prefetch happens during
    /// quiet periods when X-Plane isn't actively loading.
    Opportunistic,

    /// Prefetch disabled (manual override).
    ///
    /// Use this for debugging or when prefetch causes issues.
    Disabled,
}

impl std::fmt::Display for PrefetchMode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            PrefetchMode::Auto => write!(f, "auto"),
            PrefetchMode::Aggressive => write!(f, "aggressive"),
            PrefetchMode::Opportunistic => write!(f, "opportunistic"),
            PrefetchMode::Disabled => write!(f, "disabled"),
        }
    }
}

impl std::str::FromStr for PrefetchMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(match s.to_lowercase().as_str() {
            "aggressive" => Self::Aggressive,
            "opportunistic" => Self::Opportunistic,
            "disabled" => Self::Disabled,
            _ => Self::Auto,
        })
    }
}

/// Low performance killswitch mode.
///
/// Controls automatic disabling of prefetch when performance is too low.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum KillswitchMode {
    /// Automatically disable prefetch if throughput is too low.
    ///
    /// This is the recommended setting. If calibration shows that
    /// prefetch won't complete in time, it's disabled to avoid
    /// wasting resources.
    #[default]
    Auto,

    /// Never automatically disable prefetch.
    ///
    /// Use this if you want to force prefetch even on slow connections.
    /// May result in prefetch not completing before X-Plane needs tiles.
    Never,
}

impl std::fmt::Display for KillswitchMode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            KillswitchMode::Auto => write!(f, "auto"),
            KillswitchMode::Never => write!(f, "never"),
        }
    }
}

impl std::str::FromStr for KillswitchMode {
    type Err = std::convert::Infallible;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(match s.to_lowercase().as_str() {
            "never" => Self::Never,
            _ => Self::Auto,
        })
    }
}

/// Configuration for performance calibration.
///
/// These thresholds determine which mode is selected during calibration
/// and how often recalibration occurs.
#[derive(Debug, Clone)]
pub struct CalibrationConfig {
    /// Minimum throughput for aggressive mode (tiles/sec).
    ///
    /// If measured throughput exceeds this, aggressive (position-based)
    /// prefetch is enabled.
    pub aggressive_threshold: f64,

    /// Minimum throughput for opportunistic mode (tiles/sec).
    ///
    /// If measured throughput is between this and `aggressive_threshold`,
    /// opportunistic (circuit breaker) prefetch is enabled.
    /// Below this threshold, prefetch is disabled.
    pub opportunistic_threshold: f64,

    /// How long to measure throughput during initial calibration (seconds).
    ///
    /// Longer duration gives more accurate results but delays flight start.
    pub sample_duration: Duration,

    /// Minimum number of samples required for valid calibration.
    ///
    /// If fewer than this many tiles are generated during calibration,
    /// the calibration is considered incomplete.
    pub min_samples: usize,

    /// Confidence threshold for valid calibration (0.0 - 1.0).
    ///
    /// Calibration confidence is based on sample size and variance.
    /// Below this threshold, the calibration is considered unreliable.
    pub confidence_threshold: f64,

    /// Rolling recalibration window (how much recent history to consider).
    pub rolling_window: Duration,

    /// How often to check for recalibration.
    pub recalibration_interval: Duration,

    /// Degradation threshold (percentage of baseline).
    ///
    /// If current throughput falls below this percentage of baseline,
    /// the mode is downgraded.
    pub degradation_threshold: f64,

    /// Recovery threshold (percentage of baseline).
    ///
    /// If current throughput rises above this percentage of baseline,
    /// the mode can be upgraded.
    pub recovery_threshold: f64,
}

impl Default for CalibrationConfig {
    fn default() -> Self {
        Self {
            aggressive_threshold: 30.0,
            opportunistic_threshold: 10.0,
            sample_duration: Duration::from_secs(60),
            min_samples: 50,
            confidence_threshold: 0.7,
            rolling_window: Duration::from_secs(300), // 5 minutes
            recalibration_interval: Duration::from_secs(900), // 15 minutes
            degradation_threshold: 0.7,
            recovery_threshold: 0.9,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_default_config() {
        let config = AdaptivePrefetchConfig::default();
        assert!(config.enabled);
        assert_eq!(config.mode, PrefetchMode::Auto);
        assert_eq!(config.trigger_position, 0.35);
        assert_eq!(config.lead_distance, 2);
        assert_eq!(config.band_width, 2);
        assert_eq!(config.max_tiles_per_cycle, 3000);
    }

    #[test]
    fn test_prefetch_mode_parsing() {
        assert_eq!("auto".parse::<PrefetchMode>().unwrap(), PrefetchMode::Auto);
        assert_eq!(
            "aggressive".parse::<PrefetchMode>().unwrap(),
            PrefetchMode::Aggressive
        );
        assert_eq!(
            "opportunistic".parse::<PrefetchMode>().unwrap(),
            PrefetchMode::Opportunistic
        );
        assert_eq!(
            "disabled".parse::<PrefetchMode>().unwrap(),
            PrefetchMode::Disabled
        );
        assert_eq!(
            "unknown".parse::<PrefetchMode>().unwrap(),
            PrefetchMode::Auto
        );
    }

    #[test]
    fn test_prefetch_mode_display() {
        assert_eq!(format!("{}", PrefetchMode::Auto), "auto");
        assert_eq!(format!("{}", PrefetchMode::Aggressive), "aggressive");
        assert_eq!(format!("{}", PrefetchMode::Opportunistic), "opportunistic");
        assert_eq!(format!("{}", PrefetchMode::Disabled), "disabled");
    }

    #[test]
    fn test_killswitch_mode_parsing() {
        assert_eq!(
            "auto".parse::<KillswitchMode>().unwrap(),
            KillswitchMode::Auto
        );
        assert_eq!(
            "never".parse::<KillswitchMode>().unwrap(),
            KillswitchMode::Never
        );
        assert_eq!(
            "unknown".parse::<KillswitchMode>().unwrap(),
            KillswitchMode::Auto
        );
    }

    #[test]
    fn test_calibration_thresholds() {
        let config = CalibrationConfig::default();
        // Aggressive threshold should be higher than opportunistic
        assert!(config.aggressive_threshold > config.opportunistic_threshold);
        // Thresholds should be positive
        assert!(config.aggressive_threshold > 0.0);
        assert!(config.opportunistic_threshold > 0.0);
    }

    #[test]
    fn test_ground_detection_thresholds() {
        let config = AdaptivePrefetchConfig::default();
        // Ground speed threshold (40kt is reasonable for taxi)
        assert_eq!(config.ground_speed_threshold_kt, 40.0);
        // AGL threshold (20ft catches all ground operations)
        assert_eq!(config.agl_threshold_ft, 20.0);
    }

    #[test]
    fn test_turn_detection_thresholds() {
        let config = AdaptivePrefetchConfig::default();
        // Stability threshold should be smaller than turn threshold
        assert!(config.track_stability_threshold < config.turn_threshold);
        // Reasonable values
        assert_eq!(config.track_stability_threshold, 5.0);
        assert_eq!(config.turn_threshold, 15.0);
    }
}
